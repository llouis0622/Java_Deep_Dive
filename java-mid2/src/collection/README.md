## 3. 컬렉션 프레임워크 - ArrayList

### 1. 배열의 특징
- 자료 구조 : 여러 데이터를 구조화해서 다루는 것
- 인덱스 사용 -> 배열에서 자료 찾기
- 인덱스를 통한 입력, 변경, 조회 -> 한 번의 계산으로 자료 위치 파악 가능
- 데이터 추가 -> 새로운 데이터를 입력할 공간 확보
- 배열의 첫 번째 위치, 중간 위치에 추가 -> O(n)
- 배열의 마지막 위치에 추가 -> O(1)
- 배열의 크기를 배열을 생성하는 시점에 미리 정해야 함

### 2. 빅오(O) 표기법
- 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식
- 알고리즘이 얼마나 빠르게 실행되는지 나타냄
- O(1) : 상수 시간
- O(n) : 선형 시간
- O(n^2) : 제곱 시간
- O(log n) : 로그 시간
- O(n log n) : 선형 로그 시간

### 3. 직접 구현하는 배열 리스트
- List : 순서가 있고, 중복을 허용하는 자료 구조, 동적으로 크기 변함
- 배열 리스트(ArrayList) : 리스트 자료 구조 사용, 내부 데이터는 배열에 보관
  - 데이터 마지막에 추가 : O(1)
  - 데이터 앞, 중간에 추가 : O(n)
  - 데이터 마지막에 삭제 : O(1)
  - 데이터 앞, 중간에 삭제 : O(n)
  - 인덱스 조회 : O(1)
- 제네릭 사용 -> 타입 인자로 지정한 타입으로만 안전하게 데이터 저장, 조회 가능
- 부정확한 크기 -> 메모리 낭비
- 비효율적인 중간 데이터 추가/삭제

## 4. 컬렉션 프레임워크 - LinkedList

### 1. 노드와 연결
- 배열 리스트 단점
  - 사용하지 않는 공간 낭비
  - 중간에 데이터 추가 -> 데이터 이동 증가
- 노드 : 필요한 만큼만 메모리 확보, 데이터 추가/삭제 효율적
  - 내부에 데이터와 다음 노드에 대한 참고 보유
  - 노드가 참조를 통해 연결됨

### 2. 직접 구현하는 연결 리스트
- 연결 리스트(LinkedList) : 노드와 연결 구조를 통해 리스트 사용
  - 인덱스 조회 : O(n)
  - 검색 : O(n)
  - 앞에 추가/삭제 : O(1)
  - 뒤에 추가/삭제 : O(n)
  - 평균 추가/삭제 : O(n)

## 5. 컬렉션 프레임워크 - List

### 1. 리스트 추상화
- 컴파일 타임 : 코드 컴파일 시점
- 런타임 : 프로그램 실행 시점
- 클라이언트 클래스 컴파일 타임에 추상적인 것에 의존 -> 런타임에 의존 관계 주입을 통해 구현체 주입

### 2. 직접 구현한 리스트의 성능 비교
- 이론적으로 연결 리스트가 배열 리스트보다 효율적
- 메모리 접근 패턴, CPU 캐시 최적화 -> 배열 리스트가 성능상 유리

### 3. 자바 리스트
- Collection
  - List
    - ArrayList
    - LinkedList
- 자바 ArrayList
  - 배열을 사용해서 데이터 관리
  - 기본 용량 10, 증갸량 50%
  - 메모리 고속 복사 연산 사용
- 자바 LinkedList
  - 이중 연결 리스트 구조
  - 첫 번째 노드와 마지막 노드 둘 다 참조

### 4. 자바 리스트의 성능 비교
- 배열 리스트 : 요소들이 메모리 상에서 연속적으로 위치, CPU 캐시 효율 양호, 메모리 접근 속도 빠름
- 연결 리스트 : 각 요소가 별도의 객체로 존재, 다음 요소의 참조 저장

## 6. 컬렉션 프레임워크 - 해시(Hash)

### 1. 리스트 vs 세트
- 리스트 : 요소들의 순차적인 컬렉션
  - 순서 유지
  - 중복 허용
  - 인덱스 접근
- 세트 : 유일한 요소들의 컬렉션
  - 유일성
  - 순서 미보장
  - 빠른 검색

### 2. 직접 구현하는 Set
- 인덱스 불필요 -> 데이터 넣기, 확인하기, 삭제하기, 중복 여부 체크 중요

### 3. 해시 알고리즘
- 해시 인덱스
  - 데이터 저장 평균 : O(1)
  - 데이터 저장 최악 : O(n)
  - 데이터 조회 평균 : O(1)
  - 데이터 조회 최악 : O(n)

