## 3. 컬렉션 프레임워크 - ArrayList

### 1. 배열의 특징
- 자료 구조 : 여러 데이터를 구조화해서 다루는 것
- 인덱스 사용 -> 배열에서 자료 찾기
- 인덱스를 통한 입력, 변경, 조회 -> 한 번의 계산으로 자료 위치 파악 가능
- 데이터 추가 -> 새로운 데이터를 입력할 공간 확보
- 배열의 첫 번째 위치, 중간 위치에 추가 -> O(n)
- 배열의 마지막 위치에 추가 -> O(1)
- 배열의 크기를 배열을 생성하는 시점에 미리 정해야 함

### 2. 빅오(O) 표기법
- 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식
- 알고리즘이 얼마나 빠르게 실행되는지 나타냄
- O(1) : 상수 시간
- O(n) : 선형 시간
- O(n^2) : 제곱 시간
- O(log n) : 로그 시간
- O(n log n) : 선형 로그 시간

### 3. 직접 구현하는 배열 리스트
- List : 순서가 있고, 중복을 허용하는 자료 구조, 동적으로 크기 변함
- 배열 리스트(ArrayList) : 리스트 자료 구조 사용, 내부 데이터는 배열에 보관
  - 데이터 마지막에 추가 : O(1)
  - 데이터 앞, 중간에 추가 : O(n)
  - 데이터 마지막에 삭제 : O(1)
  - 데이터 앞, 중간에 삭제 : O(n)
  - 인덱스 조회 : O(1)
- 제네릭 사용 -> 타입 인자로 지정한 타입으로만 안전하게 데이터 저장, 조회 가능
- 부정확한 크기 -> 메모리 낭비
- 비효율적인 중간 데이터 추가/삭제

## 4. 컬렉션 프레임워크 - LinkedList

### 1. 노드와 연결
- 배열 리스트 단점
  - 사용하지 않는 공간 낭비
  - 중간에 데이터 추가 -> 데이터 이동 증가
- 노드 : 필요한 만큼만 메모리 확보, 데이터 추가/삭제 효율적
  - 내부에 데이터와 다음 노드에 대한 참고 보유
  - 노드가 참조를 통해 연결됨

### 2. 직접 구현하는 연결 리스트
- 연결 리스트(LinkedList) : 노드와 연결 구조를 통해 리스트 사용
  - 인덱스 조회 : O(n)
  - 검색 : O(n)
  - 앞에 추가/삭제 : O(1)
  - 뒤에 추가/삭제 : O(n)
  - 평균 추가/삭제 : O(n)

## 5. 컬렉션 프레임워크 - List

### 1. 리스트 추상화
- 컴파일 타임 : 코드 컴파일 시점
- 런타임 : 프로그램 실행 시점
- 클라이언트 클래스 컴파일 타임에 추상적인 것에 의존 -> 런타임에 의존 관계 주입을 통해 구현체 주입

### 2. 직접 구현한 리스트의 성능 비교
- 이론적으로 연결 리스트가 배열 리스트보다 효율적
- 메모리 접근 패턴, CPU 캐시 최적화 -> 배열 리스트가 성능상 유리

### 3. 자바 리스트
- Collection
  - List
    - ArrayList
    - LinkedList
- 자바 ArrayList
  - 배열을 사용해서 데이터 관리
  - 기본 용량 10, 증갸량 50%
  - 메모리 고속 복사 연산 사용
- 자바 LinkedList
  - 이중 연결 리스트 구조
  - 첫 번째 노드와 마지막 노드 둘 다 참조

### 4. 자바 리스트의 성능 비교
- 배열 리스트 : 요소들이 메모리 상에서 연속적으로 위치, CPU 캐시 효율 양호, 메모리 접근 속도 빠름
- 연결 리스트 : 각 요소가 별도의 객체로 존재, 다음 요소의 참조 저장

## 6. 컬렉션 프레임워크 - 해시(Hash)

### 1. 리스트 vs 세트
- 리스트 : 요소들의 순차적인 컬렉션
  - 순서 유지
  - 중복 허용
  - 인덱스 접근
- 세트 : 유일한 요소들의 컬렉션
  - 유일성
  - 순서 미보장
  - 빠른 검색

### 2. 직접 구현하는 Set
- 인덱스 불필요 -> 데이터 넣기, 확인하기, 삭제하기, 중복 여부 체크 중요

### 3. 해시 알고리즘
- 해시 인덱스
  - 데이터 저장 평균 : O(1)
  - 데이터 저장 최악 : O(n)
  - 데이터 조회 평균 : O(1)
  - 데이터 조회 최악 : O(n)

## 7. 컬렉션 프레임워크 - HashSet

### 1. 직접 구현하는 Set - MyHashSet
- Set : 중복을 허용하지 않고 순서를 보장하지 않는 자료 구조
- 해시 함수(Hash Function)
  - 임의의 길이의 데이터를 입력으로 받아, 고정된 길이의 해시값을 출력하는 함수
  - 같은 데이터 입력 -> 항상 같은 해시 코드 출력
  - 다른 데이터 입력 -> 같은 해시 코드 출력 가능성 존재, 해시 충돌
- 해시 코드(Hash Code) : 데이터를 대표하는 값
- 해시 인덱스(Hash Index) : 데이터의 저장 위치 결정, 해시 코드의 결과에 배열의 크기를 나누어 표현

### 2. 자바의 hashCode()
- 모든 객체가 자신만의 해시 코드 표현 기능 제공
- Object 해시 코드 -> 동등성 비교
- 자바 기본 클래스 해시 코드 -> 동일성 비교

### 3. equals, hashCode의 중요성
- hashCode() : 객체의 참조값을 기반으로 해시 코드 반환
- equals() : 동일성 비교
- 해시 자료 구조 사용 -> hashCode(), equals() 반드시 함께 재정의
- 해시 함수 -> 해시 코드가 최대한 충돌하지 않도록 설계

## 8. 컬렉션 프레임워크 - Set

### 1. 자바가 제공하는 Set - HashSet, LinkedHashSet
- Collection
  - Set
    - HashSet <- LinkedHashSet
    - TreeSet
- HashSet
  - 해시 자료 구조를 사용해서 요소 저장
  - 데이터의 유일설만 중요, 순서 미중요 시 적합, O(1)
- LinkedHashSet
  - 요소들은 추가된 순서대로 유지, 조회 시 추가된 순서대로 반환
  - 데이터의 유일성과 함께 삽입 순서 유지 시 적합, O(1)
- TreeSet
  - 레드-블랙 트리 내부 사용
  - 데이터를 정렬된 순서로 유지하면서 집합의 특성을 유지 시 적합, O(log n)
- 자바 HashSet 최적화 -> 배열 크기의 75%를 넘어가면 배열의 크기를 2배로 증가, 증가된 크기를 기준으로 모든 요소에 해시 재적용

## 9. 컬렉션 프레임워크 - Map, Stack, Queue

### 1. 컬렉션 프레임워크 - Map 소개
- Map : 키-값 쌍을 저정하는 자료 구조
  - 키 -> 맵 내에서 유일
  - 키 중복 불가, 값 중복 가능
  - 순서 유지하지 않음
  - HashMap <- LinkedHashMap
  - TreeMap

### 2. 컬렉션 프레임워크 - Map 구현체
- Map 키 -> Set과 동일
- key 옆에 value 추가 -> Map
- HashMap
  - 해시 사용해서 요소 저장
  - 순서 미보장, O(1)
- LinkedHashMap
  - HashMap과 유사, 연결 리스트를 사용하여 삽입 순서 최근 접근 순서에 따라 요소 유지
  - 입력 순서 보장, O(1)
- TreeMap
  - 레드-블랙 트리 기반
  - 자연 순서 또는 생성자에 제공된 Comparator에 의해 정렬
  - 키 정렬된 순서 저장, O(log n)

### 3. 스택 자료 구조
- Stack : 후입 선출(LIFO, Last In First Out)
- 자바 Stack 클래스 사용 X -> 하위 호환을 위해 존재, Deque 사용

### 4. 큐 자료 구조
- Queue : 선입 선출(FIFO, First In First Out)
- Collection
  - Queue
    - Deque
      - ArrayDeque
      - LinkedList

### 5. 덱 자료 구조
- Deque : Double Ended Queue, 양쪽 끝에서 요소 추가/제거 가능
- ArrayDeque : 특별한 원형 큐 자료 구조 사용 -> 성능 우수
- LinkedList : 배열 구조 사용
- Deque - Stack : push(), pop() 사용
- Deque - Queue : poll(), offer() 사용

## 10. 컬렉션 프레임워크 - 순회, 정렬, 전체 정리

### 1. 순회 - Iterable, Iterator, 향상된 for문
- 순회 : 자료 구조에 들어있는 데이터를 차례대로 접근해서 처리하는 것
- Iterable : 반복 가능한, Iterator 반복자 반환
- Iterator : 반복자, 다음 요소 확인/반환
- for-each : 자료 구조 순회 목적

